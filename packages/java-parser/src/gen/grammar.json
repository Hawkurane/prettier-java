[
  {
    "type": "Rule",
    "name": "typeIdentifier",
    "orgText": "() => {\n      // TODO: implement: Identifier but not var in the lexer\n      $.CONSUME(t.Identifier);\n    }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "literal",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.integerLiteral) },\n      { ALT: () => $.SUBRULE($.floatingPointLiteral) },\n      { ALT: () => $.SUBRULE($.booleanLiteral) },\n      { ALT: () => $.CONSUME(t.CharLiteral) },\n      { ALT: () => $.CONSUME(t.StringLiteral) },\n      { ALT: () => $.CONSUME(t.Null) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "integerLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "floatingPointLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "booleanLiteral",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "CharLiteral",
                "label": "'CharLiteral'",
                "idx": 0,
                "pattern": "'(?:[^\\\\']|\\\\(?:(?:[btnfr\"'\\\\\\/]|[0-7]|[0-7]{2}|[0-3][0-7]{2})|u[0-9a-fA-F]{4}))'"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "StringLiteral",
                "label": "'StringLiteral'",
                "idx": 0,
                "pattern": "\"[^\"\\\\]*(\\\\.[^\"\\\\]*)*\""
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Null",
                "label": "'null'",
                "idx": 0,
                "pattern": "null"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "integerLiteral",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.DecimalLiteral) },\n      { ALT: () => $.CONSUME(t.HexLiteral) },\n      { ALT: () => $.CONSUME(t.OctalLiteral) },\n      { ALT: () => $.CONSUME(t.BinaryLiteral) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "DecimalLiteral",
                "label": "'DecimalLiteral'",
                "idx": 0,
                "pattern": "(0|[1-9](_+[0-9]([0-9_]*[0-9])?|([0-9]([0-9_]*[0-9])?)?))[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "HexLiteral",
                "label": "'HexLiteral'",
                "idx": 0,
                "pattern": "0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "OctalLiteral",
                "label": "'OctalLiteral'",
                "idx": 0,
                "pattern": "0_*[0-7]([0-7_]*[0-7])?[lL]?"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "BinaryLiteral",
                "label": "'BinaryLiteral'",
                "idx": 0,
                "pattern": "0[bB][01]([01_]*[01])?[lL]?"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "floatingPointLiteral",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.FloatLiteral) },\n      { ALT: () => $.CONSUME(t.HexFloatLiteral) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "FloatLiteral",
                "label": "'FloatLiteral'",
                "idx": 0,
                "pattern": "[0-9]([0-9_]*[0-9])?\\.([0-9]([0-9_]*[0-9])?)?([eE][+-]?[0-9]([0-9_]*[0-9])?)?([fFdD])?|\\.[0-9]([0-9_]*[0-9])?([eE][+-]?[0-9]([0-9_]*[0-9])?)?([fFdD])?|[0-9]([0-9_]*[0-9])?[eE][+-]?[0-9]([0-9_]*[0-9])?([fFdD])?|[0-9]([0-9_]*[0-9])?([eE][+-]?[0-9]([0-9_]*[0-9])?)?[fFdD]"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "HexFloatLiteral",
                "label": "'HexFloatLiteral'",
                "idx": 0,
                "pattern": "0[xX]([0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?\\.?|([0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?)?\\.[0-9a-fA-F](([0-9a-fA-F]|'_')*[0-9a-fA-F])?)[pP][+-]?[0-9]([0-9_]*[0-9])?[fFdD]?"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "booleanLiteral",
    "orgText": "() => {\n    $.OR([{ ALT: () => $.CONSUME(t.True) }, { ALT: () => $.CONSUME(t.False) }]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "True",
                "label": "'true'",
                "idx": 0,
                "pattern": "true"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "False",
                "label": "'false'",
                "idx": 0,
                "pattern": "false"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primitiveType",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.OR([\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "numericType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.integralType) },\n      { ALT: () => $.SUBRULE($.floatingPointType) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "integralType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "floatingPointType",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "integralType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Byte) },\n      { ALT: () => $.CONSUME(t.Short) },\n      { ALT: () => $.CONSUME(t.Int) },\n      { ALT: () => $.CONSUME(t.Long) },\n      { ALT: () => $.CONSUME(t.Char) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Byte",
                "label": "'byte'",
                "idx": 0,
                "pattern": "byte"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Short",
                "label": "'short'",
                "idx": 0,
                "pattern": "short"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Int",
                "label": "'int'",
                "idx": 0,
                "pattern": "int"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Long",
                "label": "'long'",
                "idx": 0,
                "pattern": "long"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Char",
                "label": "'char'",
                "idx": 0,
                "pattern": "char"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "floatingPointType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Float) },\n      { ALT: () => $.CONSUME(t.Double) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Float",
                "label": "'float'",
                "idx": 0,
                "pattern": "float"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Double",
                "label": "'double'",
                "idx": 0,
                "pattern": "double"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "referenceType",
    "orgText": "() => {\n    $.MANY(() => {\n      // Spec Deviation: by extracting the common \"annotation\" prefix\n      // we can avoid backtracking and thus improve performance.\n      // Note that the annotation prefix is still present inside\n      // \"primitiveType\" and \"classOrInterfaceType\"\n      $.SUBRULE($.annotation);\n    });\n    // Spec Deviation: The array type \"dims\" suffix was extracted to this rule\n    // to avoid backtracking for performance reasons.\n    $.OR([\n      {\n        ALT: () => {\n          $.SUBRULE($.primitiveType);\n          $.SUBRULE($.dims);\n        }\n      },\n      {\n        // Spec Deviation: \"typeVariable\" alternative is missing because\n        //                 it is included in \"classOrInterfaceType\"\n        ALT: () => {\n          $.SUBRULE($.classOrInterfaceType);\n          $.OPTION(() => {\n            $.SUBRULE2($.dims);\n          });\n        }\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveType",
                "idx": 0
              },
              {
                "type": "NonTerminal",
                "name": "dims",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classOrInterfaceType",
                "idx": 0
              },
              {
                "type": "Option",
                "idx": 0,
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "dims",
                    "idx": 2
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classOrInterfaceType",
    "orgText": "() => {\n    // Spec Deviation: The spec says: \"classType | interfaceType\" but \"interfaceType\"\n    //                 is not mentioned in the parser because it is identical to \"classType\"\n    //                 The distinction is **semantic** not syntactic.\n    $.SUBRULE($.classType);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classType",
    "orgText": "() => {\n    // Spec Deviation: Refactored left recursion and alternation to iterations\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\n      $.CONSUME2(t.Identifier);\n      $.OPTION2({\n        // To avoid confusion with \"TypeArgumentsOrDiamond\" rule\n        // as we use the \"classType\" rule in the \"identifyNewExpressionType\"\n        // optimized lookahead rule.\n        GATE: () => tokenMatcher($.LA(2).tokenType, t.Greater) === false,\n        DEF: () => {\n          $.SUBRULE2($.typeArguments);\n        }\n      });\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 2
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceType",
    "orgText": "() => {\n    $.SUBRULE($.classType);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeVariable",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dims",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.CONSUME(t.RSquare);\n    $.MANY2(() => {\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      $.CONSUME2(t.LSquare);\n      $.CONSUME2(t.RSquare);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "LSquare",
            "label": "'['",
            "idx": 2,
            "pattern": "["
          },
          {
            "type": "Terminal",
            "name": "RSquare",
            "label": "']'",
            "idx": 2,
            "pattern": "]"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.typeParameterModifier);\n    });\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeBound);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameterModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeBound",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameterModifier",
    "orgText": "() => {\n    $.SUBRULE($.annotation);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeBound",
    "orgText": "() => {\n    $.CONSUME(t.Extends);\n    // Spec Deviation: The alternative with \"TypeVariable\" is not specified\n    //      because it's syntax is included in \"classOrInterfaceType\"\n    $.SUBRULE($.classOrInterfaceType);\n    $.MANY2(() => {\n      $.SUBRULE($.additionalBound);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "additionalBound",
    "orgText": "() => {\n    $.CONSUME(t.And);\n    $.SUBRULE($.interfaceType);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "And",
        "label": "'&'",
        "idx": 0,
        "pattern": "&"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArguments",
    "orgText": "() => {\n    $.CONSUME(t.Less);\n    $.SUBRULE($.typeArgumentList);\n    $.CONSUME(t.Greater);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "NonTerminal",
        "name": "typeArgumentList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgumentList",
    "orgText": "() => {\n    $.SUBRULE($.typeArgument);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeArgument);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeArgument",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeArgument",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgument",
    "orgText": "() => {\n    // TODO: performance: evaluate flipping the order of alternatives\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.referenceType),\n        ALT: () => $.SUBRULE($.referenceType)\n      },\n      { ALT: () => $.SUBRULE($.wildcard) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "referenceType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "wildcard",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "wildcard",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.QuestionMark);\n    $.OPTION(() => {\n      $.SUBRULE($.wildcardBounds);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "QuestionMark",
        "label": "'?'",
        "idx": 0,
        "pattern": "?"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "wildcardBounds",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "wildcardBounds",
    "orgText": "() => {\n    // TODO: consider in-lining suffix into the alternatives to match the spec more strongly\n    $.OR([\n      { ALT: () => $.CONSUME(t.Extends) },\n      { ALT: () => $.CONSUME(t.Super) }\n    ]);\n    $.SUBRULE($.referenceType);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Extends",
                "label": "'extends'",
                "idx": 0,
                "pattern": "extends"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeName",
    "orgText": "() => {\n    // Spec Deviation: The last Identifier in a \"typeName\" may not be be \"var\"\n    //                 But the parser does not check for that.\n    // TODO: post parsing semantic check: last \"Identifier\" in a \"typeName\"\n    //                                    cannot be the \"var\" keyword\n    // TODO: option 2 implement \"Not Var\" Ident using token categories?\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expressionName",
    "orgText": "() => {\n    // Spec Deviation: in-lined \"ambiguousName\" to be LL(K)\n    $.CONSUME(t.Identifier);\n    $.MANY({\n      // expressionName could be called by \"qualifiedExplicitConstructorInvocation\"\n      // in that case it may be followed by \".super\" so we need to look two tokens\n      // ahead.\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.Identifier),\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.CONSUME2(t.Identifier);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageOrTypeName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.MANY({\n      // In some contexts a \"Dot Star\" (.*) may appear\n      // after a \"packageOrTypeName\", by default Chevrotain will\n      // only look a single token ahead (Dot) to determine if another iteration\n      // exists which will cause a parsing error for inputs such as:\n      // \"import a.b.c.*\"\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.Star) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.CONSUME2(t.Identifier);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ambiguousName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classDeclaration",
    "orgText": "() => {\n    // Spec Deviation: extracted common \"{classModifier}\" prefix\n    //      extraction is safe because there are no other references to\n    //      \"normalClassDeclaration\" and \"enumDeclaration\"\n    $.MANY(() => {\n      $.SUBRULE($.classModifier);\n    });\n    $.OR([\n      { ALT: () => $.SUBRULE($.normalClassDeclaration) },\n      { ALT: () => $.SUBRULE($.enumDeclaration) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "normalClassDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "enumDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "normalClassDeclaration",
    "orgText": "() => {\n    // Spec Deviation: extracted common \"{classModifier}\" to \"classDeclaration\"\n    $.CONSUME(t.Class);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.superclass);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.superinterfaces);\n    });\n    $.SUBRULE($.classBody);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Class",
        "label": "'class'",
        "idx": 0,
        "pattern": "class"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superclass",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superinterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "classBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameters",
    "orgText": "() => {\n    $.CONSUME(t.Less);\n    $.SUBRULE($.typeParameterList);\n    $.CONSUME(t.Greater);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "NonTerminal",
        "name": "typeParameterList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeParameterList",
    "orgText": "() => {\n    $.SUBRULE($.typeParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeParameter);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "superclass",
    "orgText": "() => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.classType);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "superinterfaces",
    "orgText": "() => {\n    $.CONSUME(t.Implements);\n    $.SUBRULE($.interfaceTypeList);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Implements",
        "label": "'implements'",
        "idx": 0,
        "pattern": "implements"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceTypeList",
    "orgText": "() => {\n    $.SUBRULE($.interfaceType);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.interfaceType);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "interfaceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "interfaceType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classBody",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.classBodyDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBodyDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classBodyDeclaration",
    "orgText": "() => {\n    const nextRuleType = $.BACKTRACK_LOOKAHEAD(\n      $.identifyClassBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () =>\n          nextRuleType >= classBodyTypes.fieldDeclaration &&\n          nextRuleType <= classBodyTypes.semiColon,\n        ALT: () => $.SUBRULE($.classMemberDeclaration, { ARGS: [nextRuleType] })\n      },\n      // no gate needed for the initializers because these are LL(1) rules.\n      { ALT: () => $.SUBRULE($.instanceInitializer) },\n      { ALT: () => $.SUBRULE($.staticInitializer) },\n      {\n        GATE: () =>\n          tokenMatcher(nextRuleType, classBodyTypes.constructorDeclaration),\n        ALT: () => $.SUBRULE($.constructorDeclaration)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classMemberDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "instanceInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "staticInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constructorDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classMemberDeclaration",
    "orgText": "nextRuleType => {\n    $.OR([\n      {\n        GATE: () => nextRuleType === classBodyTypes.fieldDeclaration,\n        ALT: () => $.SUBRULE($.fieldDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.methodDeclaration,\n        ALT: () => $.SUBRULE($.methodDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "fieldDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fieldDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.fieldModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "fieldModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fieldModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Transient) },\n      { ALT: () => $.CONSUME(t.Volatile) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Transient",
                "label": "'transient'",
                "idx": 0,
                "pattern": "transient"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Volatile",
                "label": "'volatile'",
                "idx": 0,
                "pattern": "volatile"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclaratorList",
    "orgText": "() => {\n    $.SUBRULE($.variableDeclarator);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.variableDeclarator);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableDeclarator",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "variableDeclarator",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclarator",
    "orgText": "() => {\n    $.SUBRULE($.variableDeclaratorId);\n    $.OPTION(() => {\n      $.CONSUME(t.Equals);\n      $.SUBRULE($.variableInitializer);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Equals",
            "label": "'='",
            "idx": 0,
            "pattern": "="
          },
          {
            "type": "NonTerminal",
            "name": "variableInitializer",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableDeclaratorId",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableInitializer",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.expression) },\n      { ALT: () => $.SUBRULE($.arrayInitializer) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayInitializer",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannType",
    "orgText": "() => {\n    $.OR([\n      // The \"unannReferenceType\" must appear before the \"unannPrimitiveType\" type\n      // due to common prefix\n      { ALT: () => $.SUBRULE($.unannReferenceType) },\n      { ALT: () => $.SUBRULE($.unannPrimitiveType) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannReferenceType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannPrimitiveType",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannPrimitiveType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannReferenceType",
    "orgText": "() => {\n    // Spec Deviation: The array type \"dims\" suffix was extracted to this rule\n    // to avoid backtracking for performance reasons.\n    $.OR([\n      {\n        ALT: () => {\n          $.SUBRULE($.unannPrimitiveType);\n          $.SUBRULE($.dims);\n        }\n      },\n      {\n        ALT: () => {\n          $.SUBRULE($.unannClassOrInterfaceType);\n          $.OPTION(() => {\n            $.SUBRULE2($.dims);\n          });\n        }\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannPrimitiveType",
                "idx": 0
              },
              {
                "type": "NonTerminal",
                "name": "dims",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannClassOrInterfaceType",
                "idx": 0
              },
              {
                "type": "Option",
                "idx": 0,
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "dims",
                    "idx": 2
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannClassOrInterfaceType",
    "orgText": "() => {\n    // Spec Deviation: The spec says: \"UnannClassType  | UnannInterfaceType\" but \"UnannInterfaceType\"\n    //                 is not mentioned in the parser because it is identical to \"UnannClassType\"\n    //                 The distinction is **semantic** not syntactic.\n    $.SUBRULE($.unannClassType);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannClassType",
    "orgText": "() => {\n    // Spec Deviation: Refactored left recursion and alternation to iterations\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\n      $.CONSUME2(t.Identifier);\n      $.OPTION2(() => {\n        $.SUBRULE2($.typeArguments);\n      });\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 2
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannInterfaceType",
    "orgText": "() => {\n    $.SUBRULE($.unannClassType);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unannTypeVariable",
    "orgText": "() => {\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\n    // TODO: or define as token type?\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.methodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "methodModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "methodHeader",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Synchronized) },\n      { ALT: () => $.CONSUME(t.Native) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Synchronized",
                "label": "'synchronized'",
                "idx": 0,
                "pattern": "synchronized"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Native",
                "label": "'native'",
                "idx": 0,
                "pattern": "native"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodHeader",
    "orgText": "() => {\n    // Spec Deviation: extracted common prefix from both alternatives\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n      $.MANY(() => {\n        $.SUBRULE($.annotation);\n      });\n    });\n    $.SUBRULE($.result);\n    $.SUBRULE($.methodDeclarator);\n    $.OPTION2(() => {\n      $.SUBRULE($.throws);\n    });\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "result",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodDeclarator",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "throws",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "result",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.unannType) },\n      { ALT: () => $.CONSUME(t.Void) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Void",
                "label": "'void'",
                "idx": 0,
                "pattern": "void"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodDeclarator",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.formalParameterList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.dims);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "formalParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "receiverParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.SUBRULE($.unannType);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n      $.CONSUME(t.Dot);\n    });\n    $.CONSUME(t.This);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "This",
        "label": "'this'",
        "idx": 0,
        "pattern": "this"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "formalParameterList",
    "orgText": "() => {\n    $.SUBRULE($.formalParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.formalParameter);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "formalParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "formalParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "formalParameter",
    "orgText": "() => {\n    $.OR([\n      // Spec Deviation: extracted to \"variableParaRegularParameter\"\n      {\n        GATE: $.BACKTRACK($.variableParaRegularParameter),\n        ALT: () => $.SUBRULE($.variableParaRegularParameter)\n      },\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableParaRegularParameter",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableArityParameter",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableParaRegularParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorId);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableArityParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.MANY2(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.DotDotDot);\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "DotDotDot",
        "label": "'...'",
        "idx": 0,
        "pattern": "..."
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Final) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "throws",
    "orgText": "() => {\n    $.CONSUME(t.Throws);\n    $.SUBRULE($.exceptionTypeList);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Throws",
        "label": "'throws'",
        "idx": 0,
        "pattern": "throws"
      },
      {
        "type": "NonTerminal",
        "name": "exceptionTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exceptionTypeList",
    "orgText": "() => {\n    $.SUBRULE($.exceptionType);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.exceptionType);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "exceptionType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "exceptionType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exceptionType",
    "orgText": "() => {\n    // Spec Deviation: \"typeVariable\" alternative is missing because\n    //                 it is contained in classType.\n    $.SUBRULE($.classType);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "classType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodBody",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.block) },\n      { ALT: () => $.CONSUME(t.Semicolon) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "instanceInitializer",
    "orgText": "() => {\n    $.SUBRULE($.block);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "staticInitializer",
    "orgText": "() => {\n    $.CONSUME(t.Static);\n    $.SUBRULE($.block);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Static",
        "label": "'static'",
        "idx": 0,
        "pattern": "static"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.constructorModifier);\n    });\n    $.SUBRULE($.constructorDeclarator);\n    $.OPTION(() => {\n      $.SUBRULE($.throws);\n    });\n    $.SUBRULE($.constructorBody);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "constructorModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "constructorDeclarator",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "throws",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "constructorBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorDeclarator",
    "orgText": "() => {\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.SUBRULE($.simpleTypeName);\n    $.CONSUME(t.LBrace);\n    $.OPTION2({\n      // a \"formalParameterList\" and a \"receiverParameter\"\n      // cannot be distinguished using fixed lookahead.\n      GATE: $.BACKTRACK($.receiverParameter),\n      DEF: () => {\n        $.SUBRULE($.receiverParameter);\n        $.CONSUME(t.Comma);\n      }\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.formalParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "simpleTypeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "receiverParameter",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "formalParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "simpleTypeName",
    "orgText": "() => {\n    // TODO: implement: Identifier but not var\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constructorBody",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.OPTION({\n      GATE: $.BACKTRACK($.explicitConstructorInvocation),\n      DEF: () => {\n        $.SUBRULE($.explicitConstructorInvocation);\n      }\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.blockStatements);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "explicitConstructorInvocation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "explicitConstructorInvocation",
    "orgText": "() => {\n    // Spec Deviation: split into two separate sub rules.\n    $.OR([\n      { ALT: () => $.SUBRULE($.unqualifiedExplicitConstructorInvocation) },\n      { ALT: () => $.SUBRULE($.qualifiedExplicitConstructorInvocation) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unqualifiedExplicitConstructorInvocation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "qualifiedExplicitConstructorInvocation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unqualifiedExplicitConstructorInvocation",
    "orgText": "() => {\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.OR([\n      {\n        ALT: () => $.CONSUME(t.This)\n      },\n      {\n        ALT: () => $.CONSUME(t.Super)\n      }\n    ]);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "This",
                "label": "'this'",
                "idx": 0,
                "pattern": "this"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "qualifiedExplicitConstructorInvocation",
    "orgText": "() => {\n    // Spec Deviation: According to the spec the prefix may be a \"primary' as well,\n    //                 however, most primary variants don't make sense here\n    // TODO: discover which primary forms could be valid here\n    //       and handle only those specific cases.\n    //       It is best if we avoid referencing \"primary\" rule from\n    //       outside the expressions rules as the expressions rules are not aligned\n    //       to the spec style, so we want the smallest possible \"external api\"\n    //       for the expressions rules.\n    $.SUBRULE($.expressionName);\n    $.CONSUME(t.Dot);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.CONSUME(t.Super);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expressionName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Dot",
        "label": "'.'",
        "idx": 0,
        "pattern": "."
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Super",
        "label": "'super'",
        "idx": 0,
        "pattern": "super"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.classModifier);\n    });\n    $.CONSUME(t.Enum);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.superinterfaces);\n    });\n    $.SUBRULE($.enumBody);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Enum",
        "label": "'enum'",
        "idx": 0,
        "pattern": "enum"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "superinterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "enumBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumBody",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.enumConstantList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.enumBodyDeclarations);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumConstantList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumBodyDeclarations",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantList",
    "orgText": "() => {\n    $.SUBRULE($.enumConstant);\n    $.MANY({\n      GATE: () => {\n        const nextToken = $.LA(2);\n        return (\n          tokenMatcher(nextToken, t.Identifier) || tokenMatcher(nextToken, t.At)\n        );\n      },\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.enumConstant);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "enumConstant",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "enumConstant",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstant",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.enumConstantModifier);\n    });\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OPTION2(() => {\n        $.SUBRULE($.argumentList);\n      });\n      $.CONSUME(t.RBrace);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "enumConstantModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LBrace",
            "label": "'('",
            "idx": 0,
            "pattern": "("
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "argumentList",
                "idx": 0
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "RBrace",
            "label": "')'",
            "idx": 0,
            "pattern": ")"
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBody",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantModifier",
    "orgText": "() => {\n    $.SUBRULE($.annotation);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumBodyDeclarations",
    "orgText": "() => {\n    $.CONSUME(t.Semicolon);\n    $.MANY(() => {\n      $.SUBRULE($.classBodyDeclaration);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBodyDeclaration",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isClassDeclaration",
    "orgText": "() => {\n    if (\n      $.OPTION(() => {\n        $.CONSUME(t.Semicolon);\n      })\n    ) {\n      // an empty \"TypeDeclaration\"\n      return false;\n    }\n\n    try {\n      // The {classModifier} is a super grammar of the \"interfaceModifier\"\n      // So we must parse all the \"{classModifier}\" before we can distinguish\n      // between the alternatives.\n      $.MANY({\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          $.SUBRULE($.classModifier);\n        }\n      });\n    } catch (e) {\n      if (isRecognitionException(e)) {\n        // TODO: add original syntax error?\n        throw \"Cannot Identify if the <TypeDeclaration> is a <ClassDeclaration> or an <InterfaceDeclaration>\";\n      } else {\n        throw e;\n      }\n    }\n\n    const nextTokenType = this.LA(1).tokenType;\n    return (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    );\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classModifier",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyClassBodyDeclarationType",
    "orgText": "() => {\n    try {\n      let nextTokenType = this.LA(1).tokenType;\n      let nextNextTokenType = this.LA(2).tokenType;\n\n      switch (nextTokenType) {\n        case t.Semicolon:\n          return classBodyTypes.semiColon;\n        case t.LCurly:\n          return classBodyTypes.instanceInitializer;\n        case t.Static:\n          switch (nextNextTokenType) {\n            case t.LCurly:\n              return classBodyTypes.staticInitializer;\n          }\n      }\n\n      // We have to look beyond the modifiers to distinguish between the declaration types.\n      $.MANY({\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          // This alternation includes all possible modifiers for all types of \"ClassBodyDeclaration\"\n          // Certain combinations are syntactically invalid, this is **not** checked here,\n          // Invalid combinations will cause a descriptive parsing error message to be\n          // Created inside the relevant parsing rules **after** this lookahead\n          // analysis.\n          $.OR([\n            {\n              GATE: () =>\n                (tokenMatcher($.LA(1).tokenType, t.At) &&\n                  tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n              ALT: () => $.SUBRULE($.annotation)\n            },\n            { ALT: () => $.CONSUME(t.Public) },\n            { ALT: () => $.CONSUME(t.Protected) },\n            { ALT: () => $.CONSUME(t.Private) },\n            { ALT: () => $.CONSUME(t.Abstract) },\n            { ALT: () => $.CONSUME(t.Static) },\n            { ALT: () => $.CONSUME(t.Final) },\n            { ALT: () => $.CONSUME(t.Transient) },\n            { ALT: () => $.CONSUME(t.Volatile) },\n            { ALT: () => $.CONSUME(t.Synchronized) },\n            { ALT: () => $.CONSUME(t.Native) },\n            { ALT: () => $.CONSUME(t.Strictfp) }\n          ]);\n        }\n      });\n\n      nextTokenType = this.LA(1).tokenType;\n      nextNextTokenType = this.LA(2).tokenType;\n      if (\n        tokenMatcher(nextTokenType, t.Identifier) &&\n        tokenMatcher(nextNextTokenType, t.LBrace)\n      ) {\n        return classBodyTypes.constructorDeclaration;\n      }\n\n      if (\n        tokenMatcher(nextTokenType, t.Class) ||\n        tokenMatcher(nextTokenType, t.Enum)\n      ) {\n        return classBodyTypes.classDeclaration;\n      }\n\n      if (\n        tokenMatcher(nextTokenType, t.Interface) ||\n        tokenMatcher(nextTokenType, t.At)\n      ) {\n        return classBodyTypes.interfaceDeclaration;\n      }\n\n      if (tokenMatcher(nextTokenType, t.Void)) {\n        // method with result type \"void\"\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // Type Arguments common prefix\n      if (tokenMatcher(nextTokenType, t.Less)) {\n        this.SUBRULE($.typeParameters);\n        const nextTokenType = this.LA(1).tokenType;\n        const nextNextTokenType = this.LA(2).tokenType;\n        // \"<T> foo(\" -> constructor\n        if (\n          tokenMatcher(nextTokenType, t.Identifier) &&\n          tokenMatcher(nextNextTokenType, t.LBrace)\n        ) {\n          return classBodyTypes.constructorDeclaration;\n        }\n        // typeParameters can only appear in method or constructor\n        // declarations, so if it is not a constructor it must be a method\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // Only field or method declarations may be valid at this point.\n      // All other alternatives should have been attempted.\n      // **both** start with \"unannType\"\n      this.SUBRULE($.unannType);\n\n      const nextToken = this.LA(1);\n      nextNextTokenType = this.LA(2).tokenType;\n      // \"foo(...\" --> look like method start\n      if (\n        tokenMatcher(nextToken, t.Identifier) &&\n        tokenMatcher(nextNextTokenType, t.LBrace)\n      ) {\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // a valid field\n      // TODO: because we use token categories we should use tokenMatcher everywhere.\n      if (tokenMatcher(nextToken, t.Identifier)) {\n        return classBodyTypes.fieldDeclaration;\n      }\n\n      return classBodyTypes.unknown;\n    } catch (e) {\n      // TODO: add info from the original error\n      throw Error(\"Cannot Identify the type of a <classBodyDeclaration>\");\n    }\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Transient",
                    "label": "'transient'",
                    "idx": 0,
                    "pattern": "transient"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Volatile",
                    "label": "'volatile'",
                    "idx": 0,
                    "pattern": "volatile"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Synchronized",
                    "label": "'synchronized'",
                    "idx": 0,
                    "pattern": "synchronized"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Native",
                    "label": "'native'",
                    "idx": 0,
                    "pattern": "native"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "typeParameters",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "compilationUnit",
    "orgText": "() => {\n    // custom optimized backtracking lookahead logic\n    const isModule = $.BACKTRACK_LOOKAHEAD($.isModuleCompilationUnit);\n    $.OR([\n      {\n        GATE: () => isModule === false,\n        ALT: () => $.SUBRULE($.ordinaryCompilationUnit)\n      },\n      {\n        ALT: () => $.SUBRULE($.modularCompilationUnit)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ordinaryCompilationUnit",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "modularCompilationUnit",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ordinaryCompilationUnit",
    "orgText": "() => {\n    $.OPTION({\n      GATE: $.BACKTRACK($.packageDeclaration),\n      DEF: () => {\n        $.SUBRULE($.packageDeclaration);\n      }\n    });\n    $.MANY(() => {\n      $.SUBRULE3($.importDeclaration);\n    });\n    $.MANY2(() => {\n      $.SUBRULE($.typeDeclaration);\n    });\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 3
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeDeclaration",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "modularCompilationUnit",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.importDeclaration);\n    });\n    $.SUBRULE($.moduleDeclaration);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "moduleDeclaration",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.packageModifier);\n    });\n    $.CONSUME(t.Package);\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n    $.CONSUME2(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Package",
        "label": "'package'",
        "idx": 0,
        "pattern": "package"
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 2,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "packageModifier",
    "orgText": "() => {\n    $.SUBRULE($.annotation);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "importDeclaration",
    "orgText": "() => {\n    // Spec Deviation: The spec defines four different kinds of import declarations.\n    //                 Our grammar however combines those into a single rule due to difficulties\n    //                 distinguishing between the alternatives due to unbound common prefix.\n    // TODO: A post parsing step is required to align with the official specs.\n    //       The Identifier \"var\" is not allowed in all positions and variations of the importDeclaration\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Import);\n          $.OPTION(() => {\n            $.CONSUME(t.Static);\n          });\n          $.SUBRULE($.packageOrTypeName);\n          $.OPTION2(() => {\n            $.CONSUME(t.Dot);\n            $.CONSUME(t.Star);\n          });\n          $.CONSUME(t.Semicolon);\n        }\n      },\n      // Spec Deviation: The spec do not allow empty statement in between imports.\n      //                 However Java compiler consider empty statements valid, we chose\n      //                 to support that case, thus deviate from the spec.\n      //                 See here: https://github.com/jhipster/prettier-java/pull/158\n      {\n        ALT: () => $.SUBRULE($.emptyStatement)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Import",
                "label": "'import'",
                "idx": 0,
                "pattern": "import"
              },
              {
                "type": "Option",
                "idx": 0,
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "NonTerminal",
                "name": "packageOrTypeName",
                "idx": 0
              },
              {
                "type": "Option",
                "idx": 2,
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Dot",
                    "label": "'.'",
                    "idx": 0,
                    "pattern": "."
                  },
                  {
                    "type": "Terminal",
                    "name": "Star",
                    "label": "'*'",
                    "idx": 0,
                    "pattern": "*"
                  }
                ]
              },
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "emptyStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeDeclaration",
    "orgText": "() => {\n    // TODO: consider extracting the prefix modifiers here to avoid backtracking\n    const isClassDeclaration = this.BACKTRACK_LOOKAHEAD($.isClassDeclaration);\n    $.OR([\n      {\n        GATE: () => isClassDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.interfaceDeclaration) },\n      { ALT: () => $.CONSUME(t.Semicolon) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.OPTION(() => {\n      $.CONSUME(t.Open);\n    });\n    $.CONSUME(t.Module);\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n    $.CONSUME(t.LCurly);\n    $.MANY3(() => {\n      $.SUBRULE($.moduleDirective);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Open",
            "label": "'open'",
            "idx": 0,
            "pattern": "open"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Module",
        "label": "'module'",
        "idx": 0,
        "pattern": "module"
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "moduleDirective",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "moduleDirective",
    "orgText": "() => {\n    // Spec Deviation: Each of the alternatives of \"moduleDirective\" was extracted\n    //                 to its own nonTerminal, to reduce verbosity.\n    $.OR([\n      { ALT: () => $.SUBRULE($.requiresModuleDirective) },\n      { ALT: () => $.SUBRULE($.exportsModuleDirective) },\n      { ALT: () => $.SUBRULE($.opensModuleDirective) },\n      { ALT: () => $.SUBRULE($.usesModuleDirective) },\n      { ALT: () => $.SUBRULE($.providesModuleDirective) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "requiresModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "exportsModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "opensModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "usesModuleDirective",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "providesModuleDirective",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "requiresModuleDirective",
    "orgText": "() => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Requires);\n    $.MANY(() => {\n      $.SUBRULE($.requiresModifier);\n    });\n    $.SUBRULE($.moduleName);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Requires",
        "label": "'requires'",
        "idx": 0,
        "pattern": "requires"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "requiresModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "moduleName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "exportsModuleDirective",
    "orgText": "() => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Exports);\n    $.SUBRULE($.packageName);\n    $.OPTION(() => {\n      $.CONSUME(t.To);\n      $.SUBRULE($.moduleName);\n      $.MANY(() => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.moduleName);\n      });\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Exports",
        "label": "'exports'",
        "idx": 0,
        "pattern": "exports"
      },
      {
        "type": "NonTerminal",
        "name": "packageName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "To",
            "label": "'to'",
            "idx": 0,
            "pattern": "to"
          },
          {
            "type": "NonTerminal",
            "name": "moduleName",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "Terminal",
                "name": "Comma",
                "label": "','",
                "idx": 0,
                "pattern": ","
              },
              {
                "type": "NonTerminal",
                "name": "moduleName",
                "idx": 2
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "opensModuleDirective",
    "orgText": "() => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Opens);\n    $.SUBRULE($.packageName);\n    $.OPTION(() => {\n      $.CONSUME(t.To);\n      $.SUBRULE($.moduleName);\n      $.MANY(() => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.moduleName);\n      });\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Opens",
        "label": "'opens'",
        "idx": 0,
        "pattern": "opens"
      },
      {
        "type": "NonTerminal",
        "name": "packageName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "To",
            "label": "'to'",
            "idx": 0,
            "pattern": "to"
          },
          {
            "type": "NonTerminal",
            "name": "moduleName",
            "idx": 0
          },
          {
            "type": "Repetition",
            "idx": 0,
            "definition": [
              {
                "type": "Terminal",
                "name": "Comma",
                "label": "','",
                "idx": 0,
                "pattern": ","
              },
              {
                "type": "NonTerminal",
                "name": "moduleName",
                "idx": 2
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "usesModuleDirective",
    "orgText": "() => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Uses);\n    $.SUBRULE($.typeName);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Uses",
        "label": "'uses'",
        "idx": 0,
        "pattern": "uses"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "providesModuleDirective",
    "orgText": "() => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Provides);\n    $.SUBRULE($.typeName);\n    $.CONSUME(t.With);\n    $.SUBRULE2($.typeName);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE3($.typeName);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Provides",
        "label": "'provides'",
        "idx": 0,
        "pattern": "provides"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "With",
        "label": "'with'",
        "idx": 0,
        "pattern": "with"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 2
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "typeName",
            "idx": 3
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "requiresModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Transitive) },\n      { ALT: () => $.CONSUME(t.Static) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Transitive",
                "label": "'transitive'",
                "idx": 0,
                "pattern": "transitive"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isModuleCompilationUnit",
    "orgText": "() => {\n    $.OPTION(() => {\n      $.SUBRULE($.packageDeclaration);\n      // TODO: this return must be outside the OPTION at the top level rule\n      // a Java Module source code may not contain a package declaration.\n      return false;\n    });\n\n    try {\n      // the \"{importDeclaration}\" is a common prefix\n      $.MANY(() => {\n        $.SUBRULE2($.importDeclaration);\n      });\n\n      $.MANY2({\n        // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          $.SUBRULE($.annotation);\n        }\n      });\n    } catch (e) {\n      // This means we had a syntax error in the imports or annotations\n      // So we can't keep parsing deep enough to make the decision\n      if (isRecognitionException(e)) {\n        // TODO: add original syntax error?\n        throw \"Cannot Identify if the source code is an OrdinaryCompilationUnit or  ModularCompilationUnit\";\n      } else {\n        throw e;\n      }\n    }\n    const nextTokenType = this.LA(1).tokenType;\n    return (\n      tokenMatcher(nextTokenType, t.Open) ||\n      tokenMatcher(nextTokenType, t.Module)\n    );\n  }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "packageDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "importDeclaration",
            "idx": 2
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceDeclaration",
    "orgText": "() => {\n    // Spec Deviation: extracted the common \"interfaceModifier\" prefix to avoid backtracking.\n    $.MANY(() => {\n      $.SUBRULE($.interfaceModifier);\n    });\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.normalInterfaceDeclaration) },\n      { ALT: () => $.SUBRULE($.annotationTypeDeclaration) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "normalInterfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotationTypeDeclaration",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "normalInterfaceDeclaration",
    "orgText": "() => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.extendsInterfaces);\n    });\n    $.SUBRULE($.interfaceBody);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Interface",
        "label": "'interface'",
        "idx": 0,
        "pattern": "interface"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeParameters",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "extendsInterfaces",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "interfaceBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Protected",
                "label": "'protected'",
                "idx": 0,
                "pattern": "protected"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "extendsInterfaces",
    "orgText": "() => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.interfaceTypeList);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Extends",
        "label": "'extends'",
        "idx": 0,
        "pattern": "extends"
      },
      {
        "type": "NonTerminal",
        "name": "interfaceTypeList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceBody",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceMemberDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMemberDeclaration",
    "orgText": "() => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyInterfaceBodyDeclarationType\n    );\n    $.OR([\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () =>\n          detectedType === InterfaceBodyTypes.interfaceMethodDeclaration,\n        ALT: () => $.SUBRULE($.interfaceMethodDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constantDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceMethodDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.constantModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "constantModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Final",
                "label": "'final'",
                "idx": 0,
                "pattern": "final"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMethodDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMethodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "interfaceMethodModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "methodHeader",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "methodBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "interfaceMethodModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Default) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Private",
                "label": "'private'",
                "idx": 0,
                "pattern": "private"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Default",
                "label": "'default'",
                "idx": 0,
                "pattern": "default"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Static",
                "label": "'static'",
                "idx": 0,
                "pattern": "static"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Strictfp",
                "label": "'strictfp'",
                "idx": 0,
                "pattern": "strictfp"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeDeclaration",
    "orgText": "() => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.At);\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.SUBRULE($.annotationTypeBody);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "Terminal",
        "name": "Interface",
        "label": "'interface'",
        "idx": 0,
        "pattern": "interface"
      },
      {
        "type": "NonTerminal",
        "name": "typeIdentifier",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "annotationTypeBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeBody",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotationTypeMemberDeclaration",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeMemberDeclaration",
    "orgText": "() => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyAnnotationBodyDeclarationType\n    );\n    $.OR([\n      {\n        GATE: () =>\n          detectedType === AnnotationBodyTypes.annotationTypeElementDeclaration,\n        ALT: () => $.SUBRULE($.annotationTypeElementDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotationTypeElementDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "constantDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "interfaceDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Semicolon",
                "label": "';'",
                "idx": 0,
                "pattern": ";"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeElementDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeElementModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.CONSUME(t.RBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.defaultValue);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotationTypeElementModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "defaultValue",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotationTypeElementModifier",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Abstract) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Public",
                "label": "'public'",
                "idx": 0,
                "pattern": "public"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Abstract",
                "label": "'abstract'",
                "idx": 0,
                "pattern": "abstract"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "defaultValue",
    "orgText": "() => {\n    $.CONSUME(t.Default);\n    $.SUBRULE($.elementValue);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Default",
        "label": "'default'",
        "idx": 0,
        "pattern": "default"
      },
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "annotation",
    "orgText": "() => {\n    // Spec Deviation: The common prefix for all three annotation types was extracted to this rule.\n    // This was done to avoid the use of backtracking for performance reasons.\n    $.CONSUME(t.At);\n    $.SUBRULE($.typeName);\n\n    // If this optional grammar was not invoked we have a markerAnnotation\n    // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-MarkerAnnotation\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OR([\n        // normal annotation - https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-NormalAnnotation\n        { ALT: () => $.SUBRULE($.elementValuePairList) },\n        // Single Element Annotation - https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-SingleElementAnnotation\n        { ALT: () => $.SUBRULE($.elementValue) },\n        {\n          ALT: () => {\n            /* empty normal annotation contents */\n          }\n        }\n      ]);\n      $.CONSUME(t.RBrace);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "At",
        "label": "'@'",
        "idx": 0,
        "pattern": "@"
      },
      {
        "type": "NonTerminal",
        "name": "typeName",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LBrace",
            "label": "'('",
            "idx": 0,
            "pattern": "("
          },
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "elementValuePairList",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "elementValue",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": []
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "RBrace",
            "label": "')'",
            "idx": 0,
            "pattern": ")"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValuePairList",
    "orgText": "() => {\n    $.SUBRULE($.elementValuePair);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.elementValuePair);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "elementValuePair",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "elementValuePair",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValuePair",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.elementValue);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Equals",
        "label": "'='",
        "idx": 0,
        "pattern": "="
      },
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValue",
    "orgText": "() => {\n    const isSimpleElementValueAnnotation = this.BACKTRACK_LOOKAHEAD(\n      $.isSimpleElementValueAnnotation\n    );\n    $.OR([\n      // Spec Deviation: \"conditionalExpression\" replaced with \"expression\"\n      // Because we cannot differentiate between the two using fixed lookahead.\n      {\n        GATE: () => isSimpleElementValueAnnotation === false,\n        ALT: () => $.SUBRULE($.expression)\n      },\n      { ALT: () => $.SUBRULE($.elementValueArrayInitializer) },\n      {\n        GATE: () => isSimpleElementValueAnnotation === true,\n        ALT: () => $.SUBRULE($.annotation)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "elementValueArrayInitializer",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValueArrayInitializer",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.elementValueList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "elementValueList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "elementValueList",
    "orgText": "() => {\n    $.SUBRULE($.elementValue);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.elementValue);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "elementValue",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "elementValue",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyInterfaceBodyDeclarationType",
    "orgText": "() => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return InterfaceBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"interfaceMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Default) },\n          { ALT: () => $.CONSUME(t.Strictfp) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    ) {\n      return InterfaceBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return InterfaceBodyTypes.interfaceDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Void) ||\n      tokenMatcher(nextTokenType, t.Less)\n    ) {\n      // method with result type \"void\"\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n\n    // Only constant or interfaceMethod declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    const nextToken = this.LA(1);\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like method start\n    if (\n      tokenMatcher(nextToken, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextToken, t.Identifier)) {\n      return InterfaceBodyTypes.constantDeclaration;\n    }\n    return InterfaceBodyTypes.unknown;\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Default",
                    "label": "'default'",
                    "idx": 0,
                    "pattern": "default"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyAnnotationBodyDeclarationType",
    "orgText": "() => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return AnnotationBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"annotationTypeMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Strictfp) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    ) {\n      return AnnotationBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return AnnotationBodyTypes.interfaceDeclaration;\n    }\n\n    // Only constant or annotationTypeElement declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    nextTokenType = this.LA(1).tokenType;\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like annotationTypeElement start\n    if (\n      tokenMatcher(nextTokenType, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return AnnotationBodyTypes.annotationTypeElementDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextTokenType, t.Identifier)) {\n      return AnnotationBodyTypes.constantDeclaration;\n    }\n    return AnnotationBodyTypes.unknown;\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "annotation",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Public",
                    "label": "'public'",
                    "idx": 0,
                    "pattern": "public"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Protected",
                    "label": "'protected'",
                    "idx": 0,
                    "pattern": "protected"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Private",
                    "label": "'private'",
                    "idx": 0,
                    "pattern": "private"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Abstract",
                    "label": "'abstract'",
                    "idx": 0,
                    "pattern": "abstract"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Static",
                    "label": "'static'",
                    "idx": 0,
                    "pattern": "static"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Final",
                    "label": "'final'",
                    "idx": 0,
                    "pattern": "final"
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Strictfp",
                    "label": "'strictfp'",
                    "idx": 0,
                    "pattern": "strictfp"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "unannType",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isSimpleElementValueAnnotation",
    "orgText": "() => {\n    $.SUBRULE($.annotation);\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // annotation in \"ElementValue\" would be followed by one of those\n      // any other TokenType would indicate it is an annotation in a \"referenceType\"\n      // as part of a \"methodReference\" in \"primary\"\n      case t.Comma:\n      case t.Semicolon:\n      case t.RCurly:\n      case t.RBrace:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "annotation",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayInitializer",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.variableInitializerList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableInitializerList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableInitializerList",
    "orgText": "() => {\n    $.SUBRULE($.variableInitializer);\n    $.MANY({\n      // The optional last \"Comma\" of an \"arrayInitializer\"\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.variableInitializer);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "variableInitializer",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "variableInitializer",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "block",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.blockStatements);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "blockStatements",
    "orgText": "() => {\n    $.SUBRULE($.blockStatement);\n    $.MANY(() => {\n      $.SUBRULE2($.blockStatement);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "blockStatement",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "blockStatement",
    "orgText": "() => {\n    const isLocalVariableDeclaration = this.BACKTRACK_LOOKAHEAD(\n      $.isLocalVariableDeclaration\n    );\n    $.OR([\n      {\n        GATE: () => isLocalVariableDeclaration,\n        ALT: () => $.SUBRULE($.localVariableDeclarationStatement)\n      },\n      {\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.statement) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "localVariableDeclarationStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableDeclarationStatement",
    "orgText": "() => {\n    $.SUBRULE($.localVariableDeclaration);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "localVariableDeclaration",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorList);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "localVariableType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.unannType) },\n      { ALT: () => $.CONSUME(t.Var) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Var",
                "label": "'var'",
                "idx": 0,
                "pattern": "var"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statement",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.statementWithoutTrailingSubstatement) },\n      { ALT: () => $.SUBRULE($.labeledStatement) },\n      // Spec deviation: combined \"IfThenStatement\" and \"IfThenElseStatement\"\n      { ALT: () => $.SUBRULE($.ifStatement) },\n      { ALT: () => $.SUBRULE($.whileStatement) },\n      { ALT: () => $.SUBRULE($.forStatement) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statementWithoutTrailingSubstatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "labeledStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ifStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "whileStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "forStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementWithoutTrailingSubstatement",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.block) },\n      { ALT: () => $.SUBRULE($.emptyStatement) },\n      { ALT: () => $.SUBRULE($.expressionStatement) },\n      { ALT: () => $.SUBRULE($.assertStatement) },\n      { ALT: () => $.SUBRULE($.switchStatement) },\n      { ALT: () => $.SUBRULE($.doStatement) },\n      { ALT: () => $.SUBRULE($.breakStatement) },\n      { ALT: () => $.SUBRULE($.continueStatement) },\n      { ALT: () => $.SUBRULE($.returnStatement) },\n      { ALT: () => $.SUBRULE($.synchronizedStatement) },\n      { ALT: () => $.SUBRULE($.throwStatement) },\n      { ALT: () => $.SUBRULE($.tryStatement) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "emptyStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expressionStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "assertStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "switchStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "doStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "breakStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "continueStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "returnStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "synchronizedStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "throwStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "tryStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "emptyStatement",
    "orgText": "() => {\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "labeledStatement",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Colon);\n    $.SUBRULE($.statement);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Colon",
        "label": "':'",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expressionStatement",
    "orgText": "() => {\n    $.SUBRULE($.statementExpression);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementExpression",
    "orgText": "() => {\n    // Spec deviation: The many alternatives here were replaced with\n    //                 the \"expression\" rule as it contains them all,\n    //                 and distinguishing between the alternatives cannot be done\n    //                 using a fixed lookahead.\n    // TODO: verify the resulting expression is one of the valid alternatives?\n    $.SUBRULE($.expression);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ifStatement",
    "orgText": "() => {\n    $.CONSUME(t.If);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n    $.OPTION(() => {\n      $.CONSUME(t.Else);\n      $.SUBRULE2($.statement);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "If",
        "label": "'if'",
        "idx": 0,
        "pattern": "if"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Else",
            "label": "'else'",
            "idx": 0,
            "pattern": "else"
          },
          {
            "type": "NonTerminal",
            "name": "statement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "assertStatement",
    "orgText": "() => {\n    $.CONSUME(t.Assert);\n    $.SUBRULE($.expression);\n    $.OPTION(() => {\n      $.CONSUME(t.Colon);\n      $.SUBRULE2($.expression);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Assert",
        "label": "'assert'",
        "idx": 0,
        "pattern": "assert"
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Colon",
            "label": "':'",
            "idx": 0,
            "pattern": ":"
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchStatement",
    "orgText": "() => {\n    $.CONSUME(t.Switch);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.switchBlock);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Switch",
        "label": "'switch'",
        "idx": 0,
        "pattern": "switch"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "switchBlock",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchBlock",
    "orgText": "() => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      // Spec Deviation: refactored \"switchBlock\" for easy post-processing\n      //                 each case and block together in the same rule.\n      $.SUBRULE($.switchCase);\n    });\n    $.CONSUME(t.RCurly);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LCurly",
        "label": "'{'",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "switchCase",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RCurly",
        "label": "'}'",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchCase",
    "orgText": "() => {\n    $.SUBRULE($.switchLabel);\n    $.OPTION(() => {\n      $.SUBRULE($.blockStatements);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "switchLabel",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "blockStatements",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "switchLabel",
    "orgText": "() => {\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Case);\n          $.SUBRULE($.constantExpression);\n          $.CONSUME(t.Colon);\n        }\n      },\n      // SPEC Deviation: the variant with \"enumConstantName\" was removed\n      // as it can be matched by the \"constantExpression\" variant\n      // the distinction is semantic not syntactic.\n      {\n        ALT: () => {\n          $.CONSUME(t.Default);\n          $.CONSUME3(t.Colon);\n        }\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Case",
                "label": "'case'",
                "idx": 0,
                "pattern": "case"
              },
              {
                "type": "NonTerminal",
                "name": "constantExpression",
                "idx": 0
              },
              {
                "type": "Terminal",
                "name": "Colon",
                "label": "':'",
                "idx": 0,
                "pattern": ":"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Default",
                "label": "'default'",
                "idx": 0,
                "pattern": "default"
              },
              {
                "type": "Terminal",
                "name": "Colon",
                "label": "':'",
                "idx": 3,
                "pattern": ":"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enumConstantName",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "whileStatement",
    "orgText": "() => {\n    $.CONSUME(t.While);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "While",
        "label": "'while'",
        "idx": 0,
        "pattern": "while"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "doStatement",
    "orgText": "() => {\n    $.CONSUME(t.Do);\n    $.SUBRULE($.statement);\n    $.CONSUME(t.While);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Do",
        "label": "'do'",
        "idx": 0,
        "pattern": "do"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "While",
        "label": "'while'",
        "idx": 0,
        "pattern": "while"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forStatement",
    "orgText": "() => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isBasicForStatement),\n        ALT: () => $.SUBRULE($.basicForStatement)\n      },\n      { ALT: () => $.SUBRULE($.enhancedForStatement) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "basicForStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "enhancedForStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "basicForStatement",
    "orgText": "() => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.forInit);\n    });\n    $.CONSUME(t.Semicolon);\n    $.OPTION2(() => {\n      $.SUBRULE($.expression);\n    });\n    $.CONSUME2(t.Semicolon);\n    $.OPTION3(() => {\n      $.SUBRULE($.forUpdate);\n    });\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forInit",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 2,
        "pattern": ";"
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forUpdate",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forInit",
    "orgText": "() => {\n    $.OR([\n      {\n        GATE: () => $.BACKTRACK_LOOKAHEAD($.isLocalVariableDeclaration),\n        ALT: () => $.SUBRULE($.localVariableDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.statementExpressionList) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "localVariableDeclaration",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "statementExpressionList",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "forUpdate",
    "orgText": "() => {\n    $.SUBRULE($.statementExpressionList);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpressionList",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "statementExpressionList",
    "orgText": "() => {\n    $.SUBRULE($.statementExpression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.statementExpression);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "statementExpression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "statementExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "enhancedForStatement",
    "orgText": "() => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorId);\n    $.CONSUME(t.Colon);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Colon",
        "label": "':'",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "breakStatement",
    "orgText": "() => {\n    $.CONSUME(t.Break);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Break",
        "label": "'break'",
        "idx": 0,
        "pattern": "break"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "continueStatement",
    "orgText": "() => {\n    $.CONSUME(t.Continue);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Continue",
        "label": "'continue'",
        "idx": 0,
        "pattern": "continue"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "returnStatement",
    "orgText": "() => {\n    $.CONSUME(t.Return);\n    $.OPTION(() => {\n      $.SUBRULE($.expression);\n    });\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Return",
        "label": "'return'",
        "idx": 0,
        "pattern": "return"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "throwStatement",
    "orgText": "() => {\n    $.CONSUME(t.Throw);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.Semicolon);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Throw",
        "label": "'throw'",
        "idx": 0,
        "pattern": "throw"
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "synchronizedStatement",
    "orgText": "() => {\n    $.CONSUME(t.Synchronized);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.block);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Synchronized",
        "label": "'synchronized'",
        "idx": 0,
        "pattern": "synchronized"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "tryStatement",
    "orgText": "() => {\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Try);\n          $.SUBRULE($.block);\n          $.OR2([\n            {\n              ALT: () => {\n                $.SUBRULE($.catches);\n                $.OPTION(() => {\n                  $.SUBRULE($.finally);\n                });\n              }\n            },\n            { ALT: () => $.SUBRULE2($.finally) }\n          ]);\n        }\n      },\n      { ALT: () => $.SUBRULE($.tryWithResourcesStatement) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Try",
                "label": "'try'",
                "idx": 0,
                "pattern": "try"
              },
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              },
              {
                "type": "Alternation",
                "idx": 2,
                "definition": [
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "catches",
                        "idx": 0
                      },
                      {
                        "type": "Option",
                        "idx": 0,
                        "definition": [
                          {
                            "type": "NonTerminal",
                            "name": "finally",
                            "idx": 0
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "finally",
                        "idx": 2
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "tryWithResourcesStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catches",
    "orgText": "() => {\n    $.SUBRULE($.catchClause);\n    $.MANY(() => {\n      $.SUBRULE2($.catchClause);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "catchClause",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "catchClause",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchClause",
    "orgText": "() => {\n    $.CONSUME(t.Catch);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.catchFormalParameter);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.block);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Catch",
        "label": "'catch'",
        "idx": 0,
        "pattern": "catch"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "catchFormalParameter",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchFormalParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.catchType);\n    $.SUBRULE($.variableDeclaratorId);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "catchType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "catchType",
    "orgText": "() => {\n    $.SUBRULE($.unannClassType);\n    $.MANY(() => {\n      $.CONSUME(t.Or);\n      $.SUBRULE2($.classType);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unannClassType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Or",
            "label": "'|'",
            "idx": 0,
            "pattern": "|"
          },
          {
            "type": "NonTerminal",
            "name": "classType",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "finally",
    "orgText": "() => {\n    $.CONSUME(t.Finally);\n    $.SUBRULE($.block);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Finally",
        "label": "'finally'",
        "idx": 0,
        "pattern": "finally"
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "tryWithResourcesStatement",
    "orgText": "() => {\n    $.CONSUME(t.Try);\n    $.SUBRULE($.resourceSpecification);\n    $.SUBRULE($.block);\n    $.OPTION(() => {\n      $.SUBRULE($.catches);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.finally);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Try",
        "label": "'try'",
        "idx": 0,
        "pattern": "try"
      },
      {
        "type": "NonTerminal",
        "name": "resourceSpecification",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "block",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "catches",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "finally",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceSpecification",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.resourceList);\n    $.OPTION(() => {\n      $.CONSUME(t.Semicolon);\n    });\n    $.CONSUME(t.RBrace);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "resourceList",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceList",
    "orgText": "() => {\n    $.SUBRULE($.resource);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RBrace) === false,\n      DEF: () => {\n        $.CONSUME(t.Semicolon);\n        $.SUBRULE2($.resource);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "resource",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Semicolon",
            "label": "';'",
            "idx": 0,
            "pattern": ";"
          },
          {
            "type": "NonTerminal",
            "name": "resource",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resource",
    "orgText": "() => {\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.resourceInit),\n        // Spec Deviation: extracted this alternative to \"resourceInit\"\n        //                 to enable backtracking.\n        ALT: () => $.SUBRULE($.resourceInit)\n      },\n      { ALT: () => $.SUBRULE($.variableAccess) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "resourceInit",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableAccess",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "resourceInit",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.expression);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Equals",
        "label": "'='",
        "idx": 0,
        "pattern": "="
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "variableAccess",
    "orgText": "() => {\n    // Spec Deviation: both \"expressionName\" and \"fieldAccess\" can be parsed\n    //                 by the \"primary\" rule\n    // TODO: verify that the primary is a fieldAccess or an expressionName.\n    $.SUBRULE($.primary);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isBasicForStatement",
    "orgText": "() => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.forInit);\n    });\n    $.CONSUME(t.Semicolon);\n    // consuming the first semiColon distinguishes between\n    // \"basic\" and \"enhanced\" for statements\n    return true;\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "For",
        "label": "'for'",
        "idx": 0,
        "pattern": "for"
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "forInit",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Semicolon",
        "label": "';'",
        "idx": 0,
        "pattern": ";"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isLocalVariableDeclaration",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorId);\n\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // Int x;\n      case t.Semicolon:\n      // Int x, y, z;\n      case t.Comma:\n      // Int x = 5;\n      case t.Equals:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "localVariableType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "constantExpression",
    "orgText": "() => {\n    $.SUBRULE($.expression);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "expression",
    "orgText": "() => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.ternaryExpression) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ternaryExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaExpression",
    "orgText": "() => {\n    $.SUBRULE($.lambdaParameters);\n    $.CONSUME(t.Arrow);\n    $.SUBRULE($.lambdaBody);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParameters",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "Arrow",
        "label": "'->'",
        "idx": 0,
        "pattern": "->"
      },
      {
        "type": "NonTerminal",
        "name": "lambdaBody",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameters",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.lambdaParametersWithBraces) },\n      { ALT: () => $.CONSUME(t.Identifier) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaParametersWithBraces",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParametersWithBraces",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.lambdaParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "lambdaParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameterList",
    "orgText": "() => {\n    $.OR([\n      {\n        GATE: () => {\n          const nextTokType = this.LA(1).tokenType;\n          const nextNextTokType = this.LA(2).tokenType;\n          return (\n            tokenMatcher(nextTokType, t.Identifier) &&\n            (tokenMatcher(nextNextTokType, t.RBrace) ||\n              tokenMatcher(nextNextTokType, t.Comma))\n          );\n        },\n        ALT: () => $.SUBRULE($.inferredLambdaParameterList)\n      },\n      { ALT: () => $.SUBRULE($.explicitLambdaParameterList) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "inferredLambdaParameterList",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "explicitLambdaParameterList",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "inferredLambdaParameterList",
    "orgText": "() => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.CONSUME2(t.Identifier);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "explicitLambdaParameterList",
    "orgText": "() => {\n    $.SUBRULE($.lambdaParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.lambdaParameter);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParameter",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "lambdaParameter",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameter",
    "orgText": "() => {\n    // TODO: performance, investigate the performance boost that could\n    //       be gained by refactoring out the backtracking.\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.regularLambdaParameter),\n        ALT: () => $.SUBRULE($.regularLambdaParameter)\n      },\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "regularLambdaParameter",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "variableArityParameter",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "regularLambdaParameter",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.lambdaParameterType);\n    $.SUBRULE($.variableDeclaratorId);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "variableModifier",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "lambdaParameterType",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "variableDeclaratorId",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaParameterType",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.unannType) },\n      { ALT: () => $.CONSUME(t.Var) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unannType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Var",
                "label": "'var'",
                "idx": 0,
                "pattern": "var"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "lambdaBody",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.expression) },\n      { ALT: () => $.SUBRULE($.block) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "expression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "block",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ternaryExpression",
    "orgText": "() => {\n    $.SUBRULE($.binaryExpression);\n    $.OPTION(() => {\n      $.CONSUME(t.QuestionMark);\n      $.SUBRULE($.expression);\n      $.CONSUME(t.Colon);\n      // TODO: in the grammar this is limited to \"lambdaExpression: or \"conditionalExpression\"\n      $.SUBRULE2($.expression);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "binaryExpression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "QuestionMark",
            "label": "'?'",
            "idx": 0,
            "pattern": "?"
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 0
          },
          {
            "type": "Terminal",
            "name": "Colon",
            "label": "':'",
            "idx": 0,
            "pattern": ":"
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "binaryExpression",
    "orgText": "() => {\n    $.SUBRULE($.unaryExpression);\n    $.MANY(() => {\n      $.OR([\n        {\n          ALT: () => {\n            $.CONSUME(t.Instanceof);\n            $.SUBRULE($.referenceType);\n          }\n        },\n        {\n          ALT: () => {\n            $.CONSUME(t.AssignmentOperator);\n            $.SUBRULE2($.expression);\n          }\n        },\n        // This is an example of why Java does not have a well designed grammar\n        // See: https://manas.tech/blog/2008/10/12/why-java-generics-dont-have-problems-with-right-shift-operator.html\n        // TODO: ensure the LT/GT sequences have no whitespace between each other.\n        {\n          // TODO: this is a bug in Chevrotain lookahead calculation. the \"BinaryOperator\" token can match \"Less\" or \"Greater\"\n          //   as well, but because it is a **token Category** Chevrotain does not understand it need to looks two tokens ahead.\n          GATE: () =>\n            tokenMatcher($.LA(2).tokenType, t.Less) ||\n            tokenMatcher($.LA(2).tokenType, t.Greater),\n          ALT: () => {\n            $.OR2([\n              {\n                ALT: () => {\n                  $.CONSUME(t.Less);\n                  $.CONSUME2(t.Less);\n                }\n              },\n              {\n                ALT: () => {\n                  $.CONSUME(t.Greater);\n                  $.CONSUME2(t.Greater);\n                  $.OPTION(() => {\n                    $.CONSUME3(t.Greater);\n                  });\n                }\n              }\n            ]);\n            $.SUBRULE2($.unaryExpression);\n          }\n        },\n        {\n          ALT: () => {\n            $.CONSUME(t.BinaryOperator);\n            $.SUBRULE3($.unaryExpression);\n          }\n        }\n      ]);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "unaryExpression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "Instanceof",
                    "label": "'instanceof'",
                    "idx": 0,
                    "pattern": "instanceof"
                  },
                  {
                    "type": "NonTerminal",
                    "name": "referenceType",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "AssignmentOperator",
                    "label": "'AssignmentOperator'",
                    "idx": 0,
                    "pattern": "NOT_APPLICABLE"
                  },
                  {
                    "type": "NonTerminal",
                    "name": "expression",
                    "idx": 2
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Alternation",
                    "idx": 2,
                    "definition": [
                      {
                        "type": "Flat",
                        "definition": [
                          {
                            "type": "Terminal",
                            "name": "Less",
                            "label": "'<'",
                            "idx": 0,
                            "pattern": "<"
                          },
                          {
                            "type": "Terminal",
                            "name": "Less",
                            "label": "'<'",
                            "idx": 2,
                            "pattern": "<"
                          }
                        ]
                      },
                      {
                        "type": "Flat",
                        "definition": [
                          {
                            "type": "Terminal",
                            "name": "Greater",
                            "label": "'>'",
                            "idx": 0,
                            "pattern": ">"
                          },
                          {
                            "type": "Terminal",
                            "name": "Greater",
                            "label": "'>'",
                            "idx": 2,
                            "pattern": ">"
                          },
                          {
                            "type": "Option",
                            "idx": 0,
                            "definition": [
                              {
                                "type": "Terminal",
                                "name": "Greater",
                                "label": "'>'",
                                "idx": 3,
                                "pattern": ">"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "NonTerminal",
                    "name": "unaryExpression",
                    "idx": 2
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "BinaryOperator",
                    "label": "'BinaryOperator'",
                    "idx": 0,
                    "pattern": "NOT_APPLICABLE"
                  },
                  {
                    "type": "NonTerminal",
                    "name": "unaryExpression",
                    "idx": 3
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unaryExpression",
    "orgText": "() => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperator);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnaryPrefixOperator",
            "label": "'UnaryPrefixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnarySuffixOperator",
            "label": "'UnarySuffixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unaryExpressionNotPlusMinus",
    "orgText": "() => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperatorNotPlusMinus);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnaryPrefixOperatorNotPlusMinus",
            "label": "'UnaryPrefixOperatorNotPlusMinus'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "primary",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "UnarySuffixOperator",
            "label": "'UnarySuffixOperator'",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primary",
    "orgText": "() => {\n    $.SUBRULE($.primaryPrefix);\n    $.MANY(() => {\n      $.SUBRULE($.primarySuffix);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "primaryPrefix",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "primarySuffix",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primaryPrefix",
    "orgText": "() => {\n    let isCastExpression = false;\n    if (tokenMatcher($.LA(1).tokenType, t.LBrace)) {\n      isCastExpression = this.BACKTRACK_LOOKAHEAD($.isCastExpression);\n    }\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.literal) },\n      { ALT: () => $.CONSUME(t.This) },\n      { ALT: () => $.CONSUME(t.Void) },\n      // should be extracted to primitive type with optional dims suffix?\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) },\n      { ALT: () => $.SUBRULE($.fqnOrRefType) },\n      {\n        GATE: () => isCastExpression,\n        ALT: () => $.SUBRULE($.castExpression)\n      },\n      { ALT: () => $.SUBRULE($.parenthesisExpression) },\n      { ALT: () => $.SUBRULE($.newExpression) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "literal",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "This",
                "label": "'this'",
                "idx": 0,
                "pattern": "this"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Void",
                "label": "'void'",
                "idx": 0,
                "pattern": "void"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "numericType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Boolean",
                "label": "'boolean'",
                "idx": 0,
                "pattern": "boolean"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "fqnOrRefType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "castExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "parenthesisExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "newExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primarySuffix",
    "orgText": "() => {\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Dot);\n          $.OR2([\n            { ALT: () => $.CONSUME(t.This) },\n            {\n              ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n            },\n            {\n              ALT: () => {\n                $.OPTION(() => {\n                  $.SUBRULE($.typeArguments);\n                });\n                $.CONSUME(t.Identifier);\n              }\n            }\n          ]);\n        }\n      },\n      { ALT: () => $.SUBRULE($.methodInvocationSuffix) },\n      { ALT: () => $.SUBRULE($.classLiteralSuffix) },\n      { ALT: () => $.SUBRULE($.arrayAccessSuffix) },\n      { ALT: () => $.SUBRULE($.methodReferenceSuffix) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Dot",
                "label": "'.'",
                "idx": 0,
                "pattern": "."
              },
              {
                "type": "Alternation",
                "idx": 2,
                "definition": [
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "Terminal",
                        "name": "This",
                        "label": "'this'",
                        "idx": 0,
                        "pattern": "this"
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "NonTerminal",
                        "name": "unqualifiedClassInstanceCreationExpression",
                        "idx": 0
                      }
                    ]
                  },
                  {
                    "type": "Flat",
                    "definition": [
                      {
                        "type": "Option",
                        "idx": 0,
                        "definition": [
                          {
                            "type": "NonTerminal",
                            "name": "typeArguments",
                            "idx": 0
                          }
                        ]
                      },
                      {
                        "type": "Terminal",
                        "name": "Identifier",
                        "label": "Identifier",
                        "idx": 0
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodInvocationSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classLiteralSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayAccessSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "methodReferenceSuffix",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fqnOrRefType",
    "orgText": "() => {\n    $.SUBRULE($.fqnOrRefTypePart);\n\n    $.MANY2({\n      // \".class\" is a classLiteralSuffix\n      GATE: () =>\n        // avoids ambiguity with \".this\" and \".new\" which are parsed as a primary suffix.\n        tokenMatcher(this.LA(2).tokenType, t.Class) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.This) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.New) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.SUBRULE2($.fqnOrRefTypePart);\n      }\n    });\n\n    // in case of an arrayType\n    $.OPTION({\n      // it is not enough to check only the opening \"[\", we must avoid conflict with\n      // arrayAccessSuffix\n      GATE: () =>\n        tokenMatcher($.LA(1).tokenType, t.At) ||\n        tokenMatcher($.LA(2).tokenType, t.RSquare),\n      DEF: () => {\n        $.SUBRULE($.dims);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "fqnOrRefTypePart",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "NonTerminal",
            "name": "fqnOrRefTypePart",
            "idx": 2
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "fqnOrRefTypePart",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n\n    $.OPTION({\n      NAME: \"$methodTypeArguments\",\n      DEF: () => {\n        $.SUBRULE2($.typeArguments);\n      }\n    });\n\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      { ALT: () => $.CONSUME(t.Super) }\n    ]);\n\n    let isRefTypeInMethodRef = false;\n    // Performance optimization, only perform this backtracking when a '<' is found\n    // TODO: performance optimization evaluation: avoid doing this backtracking for every \"<\" encountered.\n    //       we could do it once (using global state) per \"fqnOrRefType\"\n    // We could do it only once for\n    if (tokenMatcher($.LA(1).tokenType, t.Less)) {\n      isRefTypeInMethodRef = this.BACKTRACK_LOOKAHEAD($.isRefTypeInMethodRef);\n    }\n\n    $.OPTION2({\n      NAME: \"$classTypeArguments\",\n      // unrestricted typeArguments here would create an ambiguity with \"LessThan\" operator\n      // e.g: \"var x = a < b;\"\n      // The \"<\" would be parsed as the beginning of a \"typeArguments\"\n      // and we will get an error: \"expecting '>' but found: ';'\"\n      GATE: () => isRefTypeInMethodRef,\n      DEF: () => {\n        $.SUBRULE3($.typeArguments);\n      }\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 2
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Super",
                "label": "'super'",
                "idx": 0,
                "pattern": "super"
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 3
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "parenthesisExpression",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "castExpression",
    "orgText": "() => {\n    $.OR([\n      {\n        // TODO: performance: can avoid backtracking again here, parent rule could have this information\n        //       when it checks isCastExpression (refactor needed)\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression),\n        ALT: () => $.SUBRULE($.primitiveCastExpression)\n      },\n      { ALT: () => $.SUBRULE($.referenceTypeCastExpression) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveCastExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "referenceTypeCastExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "primitiveCastExpression",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.unaryExpression);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "primitiveType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "NonTerminal",
        "name": "unaryExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "referenceTypeCastExpression",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.unaryExpressionNotPlusMinus) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "lambdaExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unaryExpressionNotPlusMinus",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "newExpression",
    "orgText": "() => {\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyNewExpressionType);\n\n    $.OR([\n      {\n        GATE: () => type === newExpressionTypes.arrayCreationExpression,\n        ALT: () => $.SUBRULE($.arrayCreationExpression)\n      },\n      {\n        GATE: () =>\n          type ===\n          newExpressionTypes.unqualifiedClassInstanceCreationExpression,\n        ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n      }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "unqualifiedClassInstanceCreationExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "unqualifiedClassInstanceCreationExpression",
    "orgText": "() => {\n    $.CONSUME(t.New);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceTypeToInstantiate",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "classBody",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classOrInterfaceTypeToInstantiate",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      $.CONSUME2(t.Identifier);\n    });\n    $.OPTION(() => {\n      $.SUBRULE($.typeArgumentsOrDiamond);\n    });\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Identifier",
        "label": "Identifier",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "Repetition",
            "idx": 3,
            "definition": [
              {
                "type": "NonTerminal",
                "name": "annotation",
                "idx": 2
              }
            ]
          },
          {
            "type": "Terminal",
            "name": "Identifier",
            "label": "Identifier",
            "idx": 2
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArgumentsOrDiamond",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "typeArgumentsOrDiamond",
    "orgText": "() => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.diamond) },\n      { ALT: () => $.SUBRULE($.typeArguments) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "diamond",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "typeArguments",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "diamond",
    "orgText": "() => {\n    $.CONSUME(t.Less);\n    $.CONSUME(t.Greater);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "Less",
        "label": "'<'",
        "idx": 0,
        "pattern": "<"
      },
      {
        "type": "Terminal",
        "name": "Greater",
        "label": "'>'",
        "idx": 0,
        "pattern": ">"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodInvocationSuffix",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "argumentList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "argumentList",
    "orgText": "() => {\n    $.SUBRULE($.expression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.expression);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "Comma",
            "label": "','",
            "idx": 0,
            "pattern": ","
          },
          {
            "type": "NonTerminal",
            "name": "expression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationExpression",
    "orgText": "() => {\n    $.CONSUME(t.New);\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.primitiveType),\n        ALT: () => $.SUBRULE($.primitiveType)\n      },\n      { ALT: () => $.SUBRULE($.classOrInterfaceType) }\n    ]);\n\n    $.OR2([\n      {\n        GATE: $.BACKTRACK($.arrayCreationDefaultInitSuffix),\n        ALT: () => $.SUBRULE($.arrayCreationDefaultInitSuffix)\n      },\n      { ALT: () => $.SUBRULE($.arrayCreationExplicitInitSuffix) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "primitiveType",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "classOrInterfaceType",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 2,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationDefaultInitSuffix",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "arrayCreationExplicitInitSuffix",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationDefaultInitSuffix",
    "orgText": "() => {\n    $.SUBRULE($.dimExprs);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dimExprs",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayCreationExplicitInitSuffix",
    "orgText": "() => {\n    $.SUBRULE($.dims);\n    $.SUBRULE($.arrayInitializer);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dims",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "arrayInitializer",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dimExprs",
    "orgText": "() => {\n    $.SUBRULE($.dimExpr);\n    $.MANY({\n      // The GATE is to distinguish DimExpr from Dims :\n      // the only difference between these two is the presence of an expression in the DimExpr\n      // Example: If the GATE is not present double[3][] won't be parsed as the parser will try to parse \"[]\"\n      // as a dimExpr instead of a dims\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RSquare) === false,\n      DEF: () => $.SUBRULE2($.dimExpr)\n    });\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "dimExpr",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dimExpr",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "dimExpr",
    "orgText": "() => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "annotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "classLiteralSuffix",
    "orgText": "() => {\n    $.MANY(() => {\n      $.CONSUME(t.LSquare);\n      $.CONSUME(t.RSquare);\n    });\n    $.CONSUME(t.Dot);\n    $.CONSUME(t.Class);\n  }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LSquare",
            "label": "'['",
            "idx": 0,
            "pattern": "["
          },
          {
            "type": "Terminal",
            "name": "RSquare",
            "label": "']'",
            "idx": 0,
            "pattern": "]"
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "Dot",
        "label": "'.'",
        "idx": 0,
        "pattern": "."
      },
      {
        "type": "Terminal",
        "name": "Class",
        "label": "'class'",
        "idx": 0,
        "pattern": "class"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "arrayAccessSuffix",
    "orgText": "() => {\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LSquare",
        "label": "'['",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "NonTerminal",
        "name": "expression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RSquare",
        "label": "']'",
        "idx": 0,
        "pattern": "]"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "methodReferenceSuffix",
    "orgText": "() => {\n    $.CONSUME(t.ColonColon);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      // TODO: a constructor method reference (\"new\") can only be used\n      //   in specific contexts, but perhaps this verification is best left\n      //   for a semantic analysis phase\n      { ALT: () => $.CONSUME(t.New) }\n    ]);\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "ColonColon",
        "label": "'::'",
        "idx": 0,
        "pattern": "::"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "typeArguments",
            "idx": 0
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "Identifier",
                "label": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "New",
                "label": "'new'",
                "idx": 0,
                "pattern": "new"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "identifyNewExpressionType",
    "orgText": "() => {\n    $.CONSUME(t.New);\n    const firstTokenAfterNew = this.LA(1).tokenType;\n\n    // not an array initialization due to the prefix \"TypeArguments\"\n    if (tokenMatcher(firstTokenAfterNew, t.Less)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    try {\n      $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    } catch (e) {\n      // if it is not a \"classOrInterfaceTypeToInstantiate\" then\n      // (assuming a valid input) we are looking at an \"arrayCreationExpression\"\n      return newExpressionTypes.arrayCreationExpression;\n    }\n\n    const firstTokenAfterClassType = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokenAfterClassType, t.LBrace)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    // The LBrace above is mandatory in \"classInstanceCreation...\" so\n    // it must be an \"arrayCreationExp\" (if the input is valid)\n    // TODO: upgrade the logic to return \"unknown\" type if at this\n    //       point it does not match \"arrayCreation\" either.\n    //   - This will provide a better error message to the user\n    //     in case of invalid inputs\n    return newExpressionTypes.arrayCreationExpression;\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "New",
        "label": "'new'",
        "idx": 0,
        "pattern": "new"
      },
      {
        "type": "NonTerminal",
        "name": "classOrInterfaceTypeToInstantiate",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isLambdaExpression",
    "orgText": "() => {\n    // TODO: this check of next two tokens is probably redundant as the normal lookahead should take care of this.\n    const firstTokenType = this.LA(1).tokenType;\n    const secondTokenType = this.LA(2).tokenType;\n    // no parent lambda \"x -> x * 2\"\n    if (\n      tokenMatcher(firstTokenType, t.Identifier) &&\n      tokenMatcher(secondTokenType, t.Arrow)\n    ) {\n      return true;\n    }\n    // Performance optimizations, fail fast if it is not a LBrace.\n    else if (tokenMatcher(firstTokenType, t.LBrace)) {\n      $.SUBRULE($.lambdaParametersWithBraces);\n      const followedByArrow = tokenMatcher(this.LA(1).tokenType, t.Arrow);\n      return followedByArrow;\n    }\n    return false;\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "lambdaParametersWithBraces",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isCastExpression",
    "orgText": "() => {\n    if (this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression)) {\n      return true;\n    }\n    return this.BACKTRACK_LOOKAHEAD($.isReferenceTypeCastExpression);\n  }",
    "definition": []
  },
  {
    "type": "Rule",
    "name": "isPrimitiveCastExpression",
    "orgText": "() => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    // No dims so this is not a reference Type\n    $.CONSUME(t.RBrace);\n    return true;\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "primitiveType",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isReferenceTypeCastExpression",
    "orgText": "() => {\n    if (firstForUnaryExpressionNotPlusMinus === undefined) {\n      const firstUnaryExpressionNotPlusMinus = this.computeContentAssist(\n        \"unaryExpressionNotPlusMinus\",\n        []\n      );\n      const nextTokTypes = firstUnaryExpressionNotPlusMinus.map(\n        x => x.nextTokenType\n      );\n      // uniq\n      firstForUnaryExpressionNotPlusMinus = nextTokTypes.filter(\n        (v, i, a) => a.indexOf(v) === i\n      );\n    }\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    const firstTokTypeAfterRBrace = this.LA(1).tokenType;\n\n    return (\n      firstForUnaryExpressionNotPlusMinus.find(tokType =>\n        tokenMatcher(firstTokTypeAfterRBrace, tokType)\n      ) !== undefined\n    );\n  }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LBrace",
        "label": "'('",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "referenceType",
        "idx": 0
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "additionalBound",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "RBrace",
        "label": "')'",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "isRefTypeInMethodRef",
    "orgText": "() => {\n    $.SUBRULE($.typeArguments);\n\n    // arrayType\n    const hasDims = $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n\n    const firstTokTypeAfterTypeArgs = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokTypeAfterTypeArgs, t.ColonColon)) {\n      return true;\n    }\n    // we must be at the end of a \"referenceType\" if \"dims\" were encountered\n    // So there is not point to check farther\n    else if (hasDims) {\n      return false;\n    }\n\n    // in the middle of a \"classReferenceType\"\n    $.OPTION2(() => {\n      $.CONSUME(t.Dot);\n      $.SUBRULE($.classOrInterfaceType);\n    });\n\n    const firstTokTypeAfterRefType = this.LA(1).tokenType;\n    return tokenMatcher(firstTokTypeAfterRefType, t.ColonColon);\n  }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "typeArguments",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "dims",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "Dot",
            "label": "'.'",
            "idx": 0,
            "pattern": "."
          },
          {
            "type": "NonTerminal",
            "name": "classOrInterfaceType",
            "idx": 0
          }
        ]
      }
    ]
  }
]